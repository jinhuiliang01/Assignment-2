<!DOCTYPE html>
<html>
  <body style="margin: 0; overflow: hidden">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <div
      id="truth-hint"
      style="
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: red;
        font-family: monospace;
        font-size: 18px;
        opacity: 0;
      "
    >
      The TRUTH is out there...
    </div>

    <script>
      let camera, scene, renderer;
      let keys = {};
      let moveSpeed = 0.1;
      let mouseSensitivity = 0.002;
      const WORLD_HEIGHT = 1.7;

      let buildings = [];
      let truthGroup;
      let truthHintElement;
      let truthDirection = new THREE.Vector3();
      let truthCenter = new THREE.Vector3(-5, WORLD_HEIGHT, -15);
      let isNearTruth = false;
      let isFacingTruth = false;
      let autoRotate = false;
      let controlsDisabled = false;
      let glitchIntensity = 0;
      let clock = new THREE.Clock();

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, WORLD_HEIGHT, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        createChaoticCity();
        createGridFloor();
        createTruthStructure();

        document.addEventListener("keydown", (e) => {
          if (!controlsDisabled) keys[e.key] = true;
          if (e.key === "Escape") controlsDisabled = false;
        });
        document.addEventListener("keyup", (e) => (keys[e.key] = false));

        document.addEventListener("click", () => {
          document.body.requestPointerLock();
        });

        document.addEventListener("mousemove", (e) => {
          if (
            document.pointerLockElement === document.body &&
            !controlsDisabled
          ) {
            camera.rotation.y -= e.movementX * mouseSensitivity;
          }
        });

        truthHintElement = document.getElementById("truth-hint");

        addTruthParticles();

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        clock.start();
      }

      function createGridFloor() {
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          side: THREE.DoubleSide,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const grid = new THREE.GridHelper(100, 50, 0x000000, 0x000000);
        grid.material.opacity = 1.0;
        grid.position.y = 0.01;
        scene.add(grid);
      }

      function createChaoticCity() {
        buildings = [];
        const spacing = 4;
        const baseSize = 1;

        for (let x = -25; x <= 25; x += spacing) {
          for (let z = -25; z <= 25; z += spacing) {
            if (Math.random() > 0.3) {
              const width = baseSize * (0.5 + Math.random());
              const height = baseSize * (0.5 + Math.random() * 5);
              const depth = baseSize * (0.5 + Math.random());
              let yPos = height / 2;
              if (Math.random() > 0.6) yPos += 2 + Math.random() * 5;

              const geometry = new THREE.BoxGeometry(width, height, depth);
              const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: Math.random() > 0.7,
              });

              const building = new THREE.Mesh(geometry, material);
              building.position.set(
                x + (Math.random() - 0.5) * 2,
                yPos,
                z + (Math.random() - 0.5) * 2
              );
              building.userData = {
                originalPosition: building.position.clone(),
                originalColor: 0xffffff,
                glitchTime: Math.random() * 10,
                glitchDuration: 0,
              };

              if (!material.wireframe) {
                const edges = new THREE.EdgesGeometry(geometry);
                const wireframe = new THREE.LineSegments(
                  edges,
                  new THREE.LineBasicMaterial({ color: 0xffffff })
                );
                building.add(wireframe);
              }

              scene.add(building);
              buildings.push(building);
            }
          }
        }
      }

      function createTruthStructure() {
        truthGroup = new THREE.Group();
        const spacing = 2.5;
        const x = truthCenter.x - 5;
        const z = truthCenter.z;
        const y = truthCenter.y;

        createLetterT(x, y, z);
        createLetterR(x + spacing, y, z);
        createLetterU(x + spacing * 2, y, z);
        createLetterT(x + spacing * 3, y, z);
        createLetterH(x + spacing * 4, y, z);

        scene.add(truthGroup);
        truthGroup.children.forEach((cube) => {
          cube.material.color.setHex(0xcccccc);
          cube.material.transparent = true;
          cube.material.opacity = 0.2;
          cube.material.emissive = undefined;
        });
      }

      function createLetterT(x, y, z) {
        for (let i = 0; i < 5; i++) addTruthCube(x, y, z + i);
        for (let i = -1; i <= 1; i++) addTruthCube(x + i, y, z + 4);
      }

      function createLetterR(x, y, z) {
        for (let i = 0; i < 5; i++) addTruthCube(x, y, z + i);
        for (let i = 0.5; i <= 1; i += 0.5) {
          addTruthCube(x + i, y, z + 4);
          addTruthCube(x + i, y, z + 2);
        }
        addTruthCube(x + 1, y, z + 3);
      }

      function createLetterU(x, y, z) {
        for (let i = 1; i < 5; i++) {
          addTruthCube(x, y, z + i);
          addTruthCube(x + 1, y, z + i);
        }
        addTruthCube(x + 0.5, y, z);
      }

      function createLetterH(x, y, z) {
        for (let i = 0; i < 5; i++) {
          addTruthCube(x, y, z + i);
          addTruthCube(x + 1, y, z + i);
        }
        addTruthCube(x + 0.5, y, z + 2);
      }

      function addTruthCube(x, y, z) {
        const geometry = new THREE.BoxGeometry(0.5, 1, 0.5);
        const material = new THREE.MeshBasicMaterial({
          color: 0xcccccc,
          transparent: true,
          opacity: 0.2,
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y, z);
        truthGroup.add(cube);
      }

      function addTruthParticles() {
        const geometry = new THREE.BufferGeometry();
        const count = 200;
        const positions = new Float32Array(count * 3);
        for (let i = 0; i < count * 3; i += 3) {
          const angle = Math.random() * Math.PI * 2;
          const radius = 3 + Math.random() * 7;
          positions[i] = truthCenter.x + Math.cos(angle) * radius;
          positions[i + 1] = truthCenter.y + (Math.random() - 0.5) * 5;
          positions[i + 2] = truthCenter.z + Math.sin(angle) * radius;
        }
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        const material = new THREE.PointsMaterial({
          size: 0.3,
          color: 0xffdddd,
          transparent: true,
          opacity: 0.4,
        });
        const particles = new THREE.Points(geometry, material);
        particles.userData = {
          isParticles: true,
          originalPositions: positions.slice(),
        };
        scene.add(particles);
      }

      function handleMovement() {
        if (controlsDisabled) return;
        const dir = new THREE.Vector3();
        if (keys["w"]) dir.z -= 1;
        if (keys["s"]) dir.z += 1;
        if (keys["a"]) dir.x -= 1;
        if (keys["d"]) dir.x += 1;

        if (!autoRotate && dir.length() > 0) {
          dir.normalize();
          const yaw = camera.rotation.y;
          const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
          const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
          camera.position.add(
            right
              .multiplyScalar(dir.x * moveSpeed)
              .add(forward.multiplyScalar(dir.z * moveSpeed))
          );
        } else if (autoRotate) {
          truthDirection.copy(truthCenter).sub(camera.position).normalize();
          const targetY = Math.atan2(truthDirection.x, truthDirection.z);
          const diff =
            ((targetY - camera.rotation.y + Math.PI) % (Math.PI * 2)) - Math.PI;
          camera.rotation.y += diff * 0.05;
        }
        camera.position.y = WORLD_HEIGHT;
      }

      function updateTruthVisibility() {
        const dist = camera.position.distanceTo(truthCenter);
        isNearTruth = dist < 15;
        const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(
          camera.quaternion
        );
        truthDirection.copy(truthCenter).sub(camera.position).normalize();
        const dot = camDir.dot(truthDirection);
        isFacingTruth = dot > 0.97 && dist < 20;

        if (isNearTruth && !isFacingTruth) {
          truthHintElement.style.opacity = 0.5;
          truthHintElement.textContent = "The TRUTH is nearby...";
          truthGroup.children.forEach((cube) => {
            cube.material.opacity = 0.4;
            cube.material.color.setHex(0xeecccc);
          });
          autoRotate = dist < 10;
          glitchIntensity = Math.max(0, 1 - dist / 20);
        } else if (isFacingTruth) {
          truthHintElement.style.opacity = 1;
          truthHintElement.textContent = "You've found the TRUTH";
          truthGroup.children.forEach((cube) => {
            cube.material.opacity = 1.0;
            cube.material.color.setHex(0xff0000);
            cube.material.emissive = new THREE.Color(0xff0000);
            cube.material.emissiveIntensity = 1.0;
            const t = clock.getElapsedTime() * 3;
            const s = Math.sin(t) * 0.2 + 1.3;
            cube.scale.set(s, s, s);
          });
          controlsDisabled = true;
          autoRotate = false;
          glitchIntensity = 1.0;
        } else {
          truthHintElement.style.opacity = 0;
          truthGroup.children.forEach((cube) => {
            cube.material.opacity = 0.2;
            cube.material.color.setHex(0xcccccc);
            cube.material.emissive = undefined;
            cube.scale.set(1, 1, 1);
          });
          autoRotate = false;
          glitchIntensity = 0.1;
        }
      }

      function updateGlitchEffect() {
        const time = clock.getElapsedTime();

        // Glitch particles
        scene.children.forEach((obj) => {
          if (obj.userData && obj.userData.isParticles) {
            const pos = obj.geometry.attributes.position.array;
            const orig = obj.userData.originalPositions;
            for (let i = 0; i < pos.length; i += 3) {
              pos[i] = orig[i] + Math.sin(time * 2 + i) * 0.5 * glitchIntensity;
              pos[i + 1] =
                orig[i + 1] + Math.cos(time * 3 + i) * 0.5 * glitchIntensity;
              pos[i + 2] =
                orig[i + 2] + Math.sin(time * 2.5 + i) * 0.5 * glitchIntensity;
            }
            obj.geometry.attributes.position.needsUpdate = true;
            obj.material.opacity = isNearTruth ? 0.7 * glitchIntensity : 0.4;
            obj.material.color.setHex(isNearTruth ? 0xff8888 : 0xffdddd);
            obj.material.size = isNearTruth ? 0.5 * (1 + glitchIntensity) : 0.3;
          }
        });

        // Glitch buildings
        buildings.forEach((b) => {
          if (b.userData.glitchDuration > 0) {
            b.position.x += (Math.random() - 0.5) * 0.2;
            b.position.y += (Math.random() - 0.5) * 0.2;
            b.material.color.setHex(Math.random() > 0.5 ? 0xff0000 : 0xffffff);
            b.userData.glitchDuration--;
          } else if (Math.random() < 0.003 + glitchIntensity * 0.02) {
            b.userData.glitchDuration = 10 + Math.floor(Math.random() * 10);
          } else {
            b.position.copy(b.userData.originalPosition);
            b.material.color.setHex(b.userData.originalColor);
          }
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        handleMovement();
        updateTruthVisibility();
        updateGlitchEffect();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
