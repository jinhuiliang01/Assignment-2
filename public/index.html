<!DOCTYPE html>
<head>
  <title>Creative-Coding-Assignment-2</title>
  <style>
    body {
      margin: 0;
    }
    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let camera, scene, renderer;
    let keys = {};
    let moveSpeed = 0.1;
    let mouseSensitivity = 0.002;
    const WORLD_HEIGHT = 1.7;
    init();
    animate();
    function init() {
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, WORLD_HEIGHT, 0);
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      // Create environment
      createChaoticCity();
      createGridFloor();
      // Controls
      document.addEventListener("keydown", (e) => (keys[e.key] = true));
      document.addEventListener("keyup", (e) => (keys[e.key] = false));
      // Mouse lock
      document.addEventListener("click", () => {
        document.body.requestPointerLock();
      });
      // Mouse movement (horizontal only)
      document.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === document.body) {
          camera.rotation.y -= e.movementX * mouseSensitivity;
          camera.rotation.x = 0; // Lock vertical rotation
        }
      });
    }
    function createGridFloor() {
      // White base plane
      const floorGeometry = new THREE.PlaneGeometry(100, 100);
      const floorMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);
      // Black grid lines
      const grid = new THREE.GridHelper(100, 50, 0x000000, 0x000000);
      grid.material.opacity = 1.0;
      grid.material.transparent = false;
      grid.position.y = 0.01; // Slightly above floor to prevent z-fighting
      scene.add(grid);
    }
    function createChaoticCity() {
      const spacing = 4;
      const baseSize = 1;
      for (let x = -25; x <= 25; x += spacing) {
        for (let z = -25; z <= 25; z += spacing) {
          if (Math.random() > 0.5) {
            // Random cube dimensions
            const width = baseSize * (0.5 + Math.random());
            const height = baseSize * (0.5 + Math.random() * 3);
            const depth = baseSize * (0.5 + Math.random());
            // Random elevation (30% chance to float)
            let yPos = height / 2;
            if (Math.random() > 0.7) {
              yPos += 2 + Math.random() * 5; // Float 2-7 units above ground
            }
            // Create irregular cube
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshBasicMaterial({
              color: 0xffffff,
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(
              x + (Math.random() - 0.5) * 2, // Add horizontal randomness
              yPos,
              z + (Math.random() - 0.5) * 2
            );
            // White wireframe
            const edges = new THREE.EdgesGeometry(geometry);
            const wireframe = new THREE.LineSegments(
              edges,
              new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            building.add(wireframe);
            scene.add(building);
          }
        }
      }
    }
    function handleMovement() {
      const direction = new THREE.Vector3();
      if (keys["w"]) direction.z -= 1;
      if (keys["s"]) direction.z += 1;
      if (keys["a"]) direction.x -= 1;
      if (keys["d"]) direction.x += 1;
      if (direction.length() === 0) return;
      direction.normalize();
      const yaw = camera.rotation.y;
      const forward = new THREE.Vector3(
        Math.sin(yaw),
        0,
        Math.cos(yaw)
      ).normalize();
      const right = new THREE.Vector3(
        Math.cos(yaw),
        0,
        -Math.sin(yaw)
      ).normalize();
      camera.position.add(
        right
          .multiplyScalar(direction.x * moveSpeed)
          .add(forward.multiplyScalar(direction.z * moveSpeed))
      );
      camera.position.y = WORLD_HEIGHT;
    }
    function animate() {
      requestAnimationFrame(animate);
      handleMovement();
      renderer.render(scene, camera);
    }
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
